{"version":3,"sources":["webpack:///./src/views/wisdomCity/dynamicRadar.vue?0be2","webpack:///src/views/wisdomCity/dynamicRadar.vue","webpack:///./src/views/wisdomCity/dynamicRadar.vue?aa2e","webpack:///./src/views/wisdomCity/dynamicRadar.vue","webpack:///./src/views/wisdomCity/dynamicRadar.vue?744d"],"names":["render","_vm","this","_h","$createElement","_c","_self","attrs","staticRenderFns","component"],"mappings":"yHAAA,IAAIA,EAAS,WAAa,IAAIC,EAAIC,KAASC,EAAGF,EAAIG,eAAmBC,EAAGJ,EAAIK,MAAMD,IAAIF,EAAG,OAAOE,EAAG,MAAM,CAACE,MAAM,CAAC,GAAK,uBAClHC,EAAkB,GCItB,OAOA,GACE,KAAF,OACE,MAAF,GACE,KAHF,WAII,MAAJ,CACM,QAAN,OAGE,SAAF,GACE,MAAF,GACE,WAAF,GACE,QAXF,aAYE,QAZF,WAaI,KAAJ,QAEE,QAAF,CACI,KADJ,WAEM,IAAN,GACQ,SAAR,EACQ,oBAAR,EACQ,UAAR,EACQ,YAAR,EACQ,UAAR,EACQ,sBAAR,EACQ,kBAAR,EACQ,aAAR,EAEQ,WAAR,EACQ,gBAAR,2CACU,IACV,+FAEQ,iBAAR,GAIM,OAAN,uBACA,uLACM,EAAN,wCACM,EAAN,oDACM,EAAN,oBACQ,YAAR,4EAQM,KAAN,WAIM,IAAN,mHACA,4BACM,KAAN,uCAII,SA5CJ,SA4CA,KAGM,EAAN,uCAEA,uBACA,uBADM,IAGN,iFAEA,4BAEA,MACA,MAEM,KAAN,gCASI,sBApEJ,SAoEA,SACM,QAAN,OAwEM,IAAN,EACA,mqEAwEA,qCACA,uCAEA,+DACA,qCACA,uCAEA,uFACA,qCACA,uCACA,wBACA,qBAEA,uBAEA,wBACA,wBACA,wBACA,wBACA,wBAEA,+BACQ,eAAR,EACQ,SAAR,CACU,eAAV,WACY,OAAZ,2DAEU,oBAAV,WACY,IAAZ,4DACA,4DAMY,OALA,EAAZ,UACY,EAAZ,UACY,EAAZ,UAEY,OAAZ,0BACA,GAEU,SAAV,EACU,mBAAV,WACY,IAAZ,4DACA,4DACA,4DAEY,EAAZ,UACY,EAAZ,UACY,EAAZ,UAEY,OAAZ,0BAEY,EAAZ,UACY,EAAZ,UACY,EAAZ,UAEY,IAAZ,+BAKY,OAJA,OAAZ,iDACY,OAAZ,4BACY,OAAZ,gCACY,OAAZ,0BACA,GAEU,YAAV,KAIM,EAAN,gCAoBI,uBA1SJ,SA0SA,WAEM,IAAN,EAEA,64CAoFA,qCAEA,uCAEA,+DAEA,qCAEA,uCAEA,uBAEA,wBAEA,wBAEA,wBAEA,+BAEQ,eAAR,EAEQ,SAAR,CAEU,eAAV,WAEY,OAAZ,2DAIU,oBAAV,WAEY,IAAZ,4DAEA,4DAUY,OARA,EAAZ,UAEY,EAAZ,UAEY,EAAZ,UAEY,OAAZ,0BAEA,GAIU,SAAV,WAEY,OAAZ,kCAIU,YAAV,KAMM,EAAN,kCCzdyc,I,wBCQrcC,EAAY,eACd,EACAT,EACAQ,GACA,EACA,KACA,WACA,MAIa,aAAAC,E,sECnBf","file":"js/chunk-b5bab280.d1723d87.js","sourcesContent":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{attrs:{\"id\":\"cesiumContainer1\"}})}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\r\n    <div id=\"cesiumContainer1\"></div>\r\n</template>\r\n\r\n<script>\r\n    var viewer = null;\r\n    var entities;\r\n    var promise;\r\n    var city;\r\n    var handler\r\n    var bloom\r\n\r\n    export default {\r\n        name: \"goSH\",\r\n        props: {},\r\n        data() {\r\n            return {\r\n                tileset: null,\r\n            };\r\n        },\r\n        computed: {},\r\n        watch: {},\r\n        components: {},\r\n        created() { },\r\n        mounted() {\r\n            this.init();\r\n        },\r\n        methods: {\r\n            init() {\r\n                let viewerOption = {\r\n                    infoBox: false,\r\n                    selectionIndicator: false,\r\n                    geocoder: false, // 地理位置查询定位控件\r\n                    homeButton: false, // 默认相机位置控件\r\n                    timeline: false, // 时间滚动条控件\r\n                    navigationHelpButton: false, // 默认的相机控制提示控件\r\n                    fullscreenButton: false, // 全屏控件\r\n                    scene3DOnly: true, // 每个几何实例仅以3D渲染以节省GPU内存\r\n                    // baseLayerPicker: true, // 底图切换控件\r\n                    animation: false, // 控制场景动画的播放速度控件\r\n                    imageryProvider: new Cesium.ArcGisMapServerImageryProvider({\r\n                        url:\r\n                            \"http://cache1.arcgisonline.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer\",\r\n                    }),\r\n                    baseLayerPicker: false,\r\n                };\r\n\r\n                //使用ion数据   需要先申请token\r\n                Cesium.Ion.defaultAccessToken =\r\n                    \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzZjFjYmZmNS1hYmNjLTRhZWUtYjlkNi02ODVmOGRjNGQ2N2MiLCJpZCI6Mzg4MzUsImlhdCI6MTYwNjg3Mzk0MX0.R0iO5eELEnpRqQCzoa33UZakcsTYUidaTP9nLa342wY\";\r\n                viewer = new Cesium.Viewer(\"cesiumContainer1\", viewerOption);\r\n                viewer._cesiumWidget._creditContainer.style.display = \"none\"; // 隐藏版权\r\n                viewer.scene.camera.flyTo({\r\n                    destination: Cesium.Cartesian3.fromDegrees(121.41440447172941, 31.148724746744023, 75000)\r\n                    //   destination: new Cesium.Cartesian3(-2852038.506894064, 4656753.071879653, 3286786.358214652),\r\n                    //   orientation: {\r\n                    //     heading: 0.4417702951554947,\r\n                    //     pitch: -0.30187320702800813,\r\n                    //   },\r\n                });\r\n                /* 雷达扫描线 */\r\n                this.initData()\r\n\r\n\r\n                /* 扩散扫描线 */\r\n                var CartographicCenter = new Cesium.Cartographic(Cesium.Math.toRadians(121.41440447172941), Cesium.Math.toRadians(31.148724746744023), 1000);\r\n                var scanColor = new Cesium.Color(0, 0, 1, 1);\r\n                this.AddCircleScanPostStage(viewer, CartographicCenter, 10000, scanColor, 4000);\r\n\r\n            },\r\n\r\n            initData(longitude, latitude) {\r\n                // 防止移动、放大缩小会视觉偏移depthTestAgainstTerrain \r\n                // 设置该属性为true之后，标绘将位于地形的顶部；如果设为false（默认值），那么标绘将位于平面上。缺陷：开启该属性有可能在切换图层时会引发标绘消失的bug。\r\n                viewer.scene.globe.depthTestAgainstTerrain = true;\r\n                // 定义经纬度\r\n                var longitude = \"121.41440447172941\";\r\n                var latitude = \"31.148724746744023\";\r\n                // 雷达扫描中心（三维空间坐标）\r\n                var geographySpace = new Cesium.Cartographic(Cesium.Math.toRadians(longitude), Cesium.Math.toRadians(latitude), 5000);\r\n                // 扫描颜色\r\n                var scanColor = new Cesium.Color(1.0, 0.0, 0.0, 1);\r\n                // 持续时间 毫秒\r\n                var duration = 4000;\r\n                var radarRadius = 8000\r\n                // 绘制平面雷达扫描线\r\n                this.addRadarScanPostStage(geographySpace, radarRadius, scanColor, duration);\r\n            },\r\n            /*\r\n              添加雷达扫描线 地形遮挡开启\r\n              cartographicCenter 扫描中心【new Cesium.Cartographic(Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat), 0);】\r\n              radius  半径 米【1500】\r\n              scanColor 扫描颜色【new Cesium.Color(1.0, 0.0, 0.0, 1)】\r\n              duration 持续时间 毫秒【4000】\r\n            */\r\n            addRadarScanPostStage(cartographicCenter, radius, scanColor, duration) {\r\n                console.log(cartographicCenter)\r\n                /* // 彩色纹理\r\n                uniform sampler2D colorTexture;\r\n                // 深度纹理\r\n                uniform sampler2D depthTexture;\r\n                // 纹理坐标\r\n                varying vec2 v_textureCoordinates;\r\n                // 扫描中心\r\n                uniform vec4 u_scanCenterEC;\r\n                // 扫描平面法线EC\r\n                uniform vec3 u_scanPlaneNormalEC;\r\n                // 扫描线法线EC\r\n                uniform vec3 u_scanLineNormalEC;\r\n                // 半径\r\n                uniform float u_radius;\r\n                // 扫描的颜色\r\n                uniform vec4 u_scanColor;\r\n                vec4 toEye( in vec2 uv, infloat depth) {\r\n                    vec2 xy = vec2((uv.x * 2.0 - 1.0), (uv.y * 2.0 - 1.0));\r\n                    vec4 posInCamera = czm_inverseProjection * vec4(xy, depth, 1.0);\r\n                    posInCamera = posInCamera / posInCamera.w;\r\n                    return posInCamera;\r\n                }\r\n                bool isPointOnLineRight( in vec3 ptOnLine, invec3 lineNormal, invec3 testPt) {\r\n                    vec3 v01 = testPt - ptOnLine;\r\n                    normalize(v01);\r\n                    vec3 temp = cross(v01, lineNormal);\r\n                    float d = dot(temp, u_scanPlaneNormalEC);\r\n                    return d > 0.5;\r\n                }\r\n                vec3 pointProjectOnPlane( in vec3 planeNormal, invec3 planeOrigin, invec3 point) {\r\n                    vec3 v01 = point - planeOrigin;\r\n                    float d = dot(planeNormal, v01);\r\n                    return (point - planeNormal * d);\r\n                }\r\n                float distancePointToLine( in vec3 ptOnLine, invec3 lineNormal, invec3 testPt) {\r\n                    vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\r\n                    return length(tempPt - ptOnLine);\r\n                }\r\n                float getDepth( in vec4 depth) {\r\n                    float z_window = czm_unpackDepth(depth);\r\n                    z_window = czm_reverseLogDepth(z_window);\r\n                    float n_range = czm_depthRange.near;\r\n                    float f_range = czm_depthRange.far;\r\n                    return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\r\n                }\r\n                void main() {\r\n                    // 得到釉色 = 结构二维(彩色纹理,纹理坐标)\r\n                    gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\r\n                    // 深度 = (釉色 = 结构二维(深度纹理,纹理坐标))\r\n                    float depth = getDepth(texture2D(depthTexture, v_textureCoordinates));\r\n                    // 视角 = (纹理坐标,深度)\r\n                    vec4 viewPos = toEye(v_textureCoordinates, depth);\r\n                    // 平面点投影 = (扫描平面法线,扫描中心,视角)\r\n                    vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\r\n                    // 差值\r\n                    float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\r\n                    // 直径 = 两个半径\r\n                    float twou_radius = u_radius * 2.0;\r\n                    if (dis < u_radius) {\r\n                        float f0 = 1.0 - abs(u_radius - dis) / u_radius;\r\n                        f0 = pow(f0, 64.0);\r\n                        vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\r\n                        float f = 0.0;\r\n                        if (isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz)) {\r\n                            float dis1 = length(prjOnPlane.xyz - lineEndPt);\r\n                            f = abs(twou_radius - dis1) / twou_radius;\r\n                            f = pow(f, 3.0);\r\n                        }\r\n                        gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\r\n                    }\r\n                } */\r\n                var ScanSegmentShader =\r\n                    \"uniform sampler2D colorTexture;\\n\" +\r\n                    \"uniform sampler2D depthTexture;\\n\" +\r\n                    \"varying vec2 v_textureCoordinates;\\n\" +\r\n                    \"uniform vec4 u_scanCenterEC;\\n\" +\r\n                    \"uniform vec3 u_scanPlaneNormalEC;\\n\" +\r\n                    \"uniform vec3 u_scanLineNormalEC;\\n\" +\r\n                    \"uniform float u_radius;\\n\" +\r\n                    \"uniform vec4 u_scanColor;\\n\" +\r\n\r\n                    \"vec4 toEye(in vec2 uv, in float depth)\\n\" +\r\n                    \" {\\n\" +\r\n                    \" vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\\n\" +\r\n                    \" vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\\n\" +\r\n                    \" posInCamera =posInCamera / posInCamera.w;\\n\" +\r\n                    \" return posInCamera;\\n\" +\r\n                    \" }\\n\" +\r\n\r\n                    \"bool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\\n\" +\r\n                    \"{\\n\" +\r\n                    \"vec3 v01 = testPt - ptOnLine;\\n\" +\r\n                    \"normalize(v01);\\n\" +\r\n                    \"vec3 temp = cross(v01, lineNormal);\\n\" +\r\n                    \"float d = dot(temp, u_scanPlaneNormalEC);\\n\" +\r\n                    \"return d > 0.5;\\n\" +\r\n                    \"}\\n\" +\r\n\r\n                    \"vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\\n\" +\r\n                    \"{\\n\" +\r\n                    \"vec3 v01 = point -planeOrigin;\\n\" +\r\n                    \"float d = dot(planeNormal, v01) ;\\n\" +\r\n                    \"return (point - planeNormal * d);\\n\" +\r\n                    \"}\\n\" +\r\n\r\n                    \"float distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\\n\" +\r\n                    \"{\\n\" +\r\n                    \"vec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\\n\" +\r\n                    \"return length(tempPt - ptOnLine);\\n\" +\r\n                    \"}\\n\" +\r\n\r\n                    \"float getDepth(in vec4 depth)\\n\" +\r\n                    \"{\\n\" +\r\n                    \"float z_window = czm_unpackDepth(depth);\\n\" +\r\n                    \"z_window = czm_reverseLogDepth(z_window);\\n\" +\r\n                    \"float n_range = czm_depthRange.near;\\n\" +\r\n                    \"float f_range = czm_depthRange.far;\\n\" +\r\n                    \"return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\\n\" +\r\n                    \"}\\n\" +\r\n\r\n                    \"void main()\\n\" +\r\n                    \"{\\n\" +\r\n                    \"gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\\n\" +\r\n                    \"float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\\n\" +\r\n                    \"vec4 viewPos = toEye(v_textureCoordinates, depth);\\n\" +\r\n                    \"vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\\n\" +\r\n                    \"float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\\n\" +\r\n                    \"float twou_radius = u_radius * 2.0;\\n\" +\r\n                    \"if(dis < u_radius)\\n\" +\r\n                    \"{\\n\" +\r\n                    \"float f0 = 1.0 -abs(u_radius - dis) / u_radius;\\n\" +\r\n                    \"f0 = pow(f0, 64.0);\\n\" +\r\n                    \"vec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\\n\" +\r\n                    \"float f = 0.0;\\n\" +\r\n                    \"if(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))\\n\" +\r\n                    \"{\\n\" +\r\n                    \"float dis1= length(prjOnPlane.xyz - lineEndPt);\\n\" +\r\n                    \"f = abs(twou_radius -dis1) / twou_radius;\\n\" +\r\n                    \"f = pow(f, 3.0);\\n\" +\r\n                    \"}\\n\" +\r\n                    \"gl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\\n\" +\r\n                    \"}\\n\" +\r\n                    \"}\\n\";\r\n\r\n                var _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter);\r\n                var _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);\r\n\r\n                var _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);\r\n                var _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1);\r\n                var _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);\r\n\r\n                var _CartographicCenter2 = new Cesium.Cartographic(cartographicCenter.longitude + Cesium.Math.toRadians(0.001), cartographicCenter.latitude, cartographicCenter.height);\r\n                var _Cartesian3Center2 = Cesium.Cartographic.toCartesian(_CartographicCenter2);\r\n                var _Cartesian4Center2 = new Cesium.Cartesian4(_Cartesian3Center2.x, _Cartesian3Center2.y, _Cartesian3Center2.z, 1);\r\n                var _RotateQ = new Cesium.Quaternion();\r\n                var _RotateM = new Cesium.Matrix3();\r\n\r\n                var _time = (new Date()).getTime();\r\n\r\n                var _scratchCartesian4Center = new Cesium.Cartesian4();\r\n                var _scratchCartesian4Center1 = new Cesium.Cartesian4();\r\n                var _scratchCartesian4Center2 = new Cesium.Cartesian4();\r\n                var _scratchCartesian3Normal = new Cesium.Cartesian3();\r\n                var _scratchCartesian3Normal1 = new Cesium.Cartesian3();\r\n\r\n                var ScanPostStage = new Cesium.PostProcessStage({\r\n                    fragmentShader: ScanSegmentShader,\r\n                    uniforms: {\r\n                        u_scanCenterEC: function () {\r\n                            return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);\r\n                        },\r\n                        u_scanPlaneNormalEC: function () {\r\n                            var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);\r\n                            var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);\r\n                            _scratchCartesian3Normal.x = temp1.x - temp.x;\r\n                            _scratchCartesian3Normal.y = temp1.y - temp.y;\r\n                            _scratchCartesian3Normal.z = temp1.z - temp.z;\r\n\r\n                            Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);\r\n                            return _scratchCartesian3Normal;\r\n                        },\r\n                        u_radius: radius,\r\n                        u_scanLineNormalEC: function () {\r\n                            var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);\r\n                            var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);\r\n                            var temp2 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center2, _scratchCartesian4Center2);\r\n\r\n                            _scratchCartesian3Normal.x = temp1.x - temp.x;\r\n                            _scratchCartesian3Normal.y = temp1.y - temp.y;\r\n                            _scratchCartesian3Normal.z = temp1.z - temp.z;\r\n\r\n                            Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);\r\n\r\n                            _scratchCartesian3Normal1.x = temp2.x - temp.x;\r\n                            _scratchCartesian3Normal1.y = temp2.y - temp.y;\r\n                            _scratchCartesian3Normal1.z = temp2.z - temp.z;\r\n\r\n                            var tempTime = (((new Date()).getTime() - _time) % duration) / duration;\r\n                            Cesium.Quaternion.fromAxisAngle(_scratchCartesian3Normal, tempTime * Cesium.Math.PI * 2, _RotateQ);\r\n                            Cesium.Matrix3.fromQuaternion(_RotateQ, _RotateM);\r\n                            Cesium.Matrix3.multiplyByVector(_RotateM, _scratchCartesian3Normal1, _scratchCartesian3Normal1);\r\n                            Cesium.Cartesian3.normalize(_scratchCartesian3Normal1, _scratchCartesian3Normal1);\r\n                            return _scratchCartesian3Normal1;\r\n                        },\r\n                        u_scanColor: scanColor\r\n                    }\r\n                });\r\n\r\n                viewer.scene.postProcessStages.add(ScanPostStage);\r\n            }\r\n            //----------------------------------------------------------------------------------------------\r\n            //添加扫描线\r\n            /*\r\n     \r\n        添加扫描线 depth关闭 \r\n     \r\n         viewer\r\n     \r\n         cartographicCenter 扫描中心\r\n     \r\n         maxRadius 最大半径 米\r\n     \r\n         scanColor 扫描颜色\r\n     \r\n         duration 持续时间 毫秒\r\n     \r\n         */\r\n\r\n            , AddCircleScanPostStage(viewer, cartographicCenter, maxRadius, scanColor, duration) {\r\n\r\n                var ScanSegmentShader =\r\n\r\n                    \"uniform sampler2D colorTexture;\\n\" +\r\n\r\n                    \"uniform sampler2D depthTexture;\\n\" +\r\n\r\n                    \"varying vec2 v_textureCoordinates;\\n\" +\r\n\r\n                    \"uniform vec4 u_scanCenterEC;\\n\" +\r\n\r\n                    \"uniform vec3 u_scanPlaneNormalEC;\\n\" +\r\n\r\n                    \"uniform float u_radius;\\n\" +\r\n\r\n                    \"uniform vec4 u_scanColor;\\n\" +\r\n\r\n                    \"vec4 toEye(in vec2 uv, in float depth)\\n\" +\r\n\r\n                    \" {\\n\" +\r\n\r\n                    \" vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\\n\" +\r\n\r\n                    \" vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\\n\" +\r\n\r\n                    \" posInCamera =posInCamera / posInCamera.w;\\n\" +\r\n\r\n                    \" return posInCamera;\\n\" +\r\n\r\n                    \" }\\n\" +\r\n\r\n                    \"vec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\\n\" +\r\n\r\n                    \"{\\n\" +\r\n\r\n                    \"vec3 v01 = point -planeOrigin;\\n\" +\r\n\r\n                    \"float d = dot(planeNormal, v01) ;\\n\" +\r\n\r\n                    \"return (point - planeNormal * d);\\n\" +\r\n\r\n                    \"}\\n\" +\r\n\r\n                    \"float getDepth(in vec4 depth)\\n\" +\r\n\r\n                    \"{\\n\" +\r\n\r\n                    \"float z_window = czm_unpackDepth(depth);\\n\" +\r\n\r\n                    \"z_window = czm_reverseLogDepth(z_window);\\n\" +\r\n\r\n                    \"float n_range = czm_depthRange.near;\\n\" +\r\n\r\n                    \"float f_range = czm_depthRange.far;\\n\" +\r\n\r\n                    \"return (2.0 * z_window - n_range - f_range) / (f_range - n_range);\\n\" +\r\n\r\n                    \"}\\n\" +\r\n\r\n                    \"void main()\\n\" +\r\n\r\n                    \"{\\n\" +\r\n\r\n                    \"gl_FragColor = texture2D(colorTexture, v_textureCoordinates);\\n\" +\r\n\r\n                    \"float depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\\n\" +\r\n\r\n                    \"vec4 viewPos = toEye(v_textureCoordinates, depth);\\n\" +\r\n\r\n                    \"vec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\\n\" +\r\n\r\n                    \"float dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\\n\" +\r\n\r\n                    \"if(dis < u_radius)\\n\" +\r\n\r\n                    \"{\\n\" +\r\n\r\n                    \"float f = 1.0 -abs(u_radius - dis) / u_radius;\\n\" +\r\n\r\n                    \"f = pow(f, 4.0);\\n\" +\r\n\r\n                    \"gl_FragColor = mix(gl_FragColor, u_scanColor, f);\\n\" +\r\n\r\n                    \"}\\n\" +\r\n\r\n                    \"}\\n\";\r\n\r\n                var _Cartesian3Center = Cesium.Cartographic.toCartesian(cartographicCenter);\r\n\r\n                var _Cartesian4Center = new Cesium.Cartesian4(_Cartesian3Center.x, _Cartesian3Center.y, _Cartesian3Center.z, 1);\r\n\r\n                var _CartographicCenter1 = new Cesium.Cartographic(cartographicCenter.longitude, cartographicCenter.latitude, cartographicCenter.height + 500);\r\n\r\n                var _Cartesian3Center1 = Cesium.Cartographic.toCartesian(_CartographicCenter1);\r\n\r\n                var _Cartesian4Center1 = new Cesium.Cartesian4(_Cartesian3Center1.x, _Cartesian3Center1.y, _Cartesian3Center1.z, 1);\r\n\r\n                var _time = (new Date()).getTime();\r\n\r\n                var _scratchCartesian4Center = new Cesium.Cartesian4();\r\n\r\n                var _scratchCartesian4Center1 = new Cesium.Cartesian4();\r\n\r\n                var _scratchCartesian3Normal = new Cesium.Cartesian3();\r\n\r\n                var ScanPostStage = new Cesium.PostProcessStage({\r\n\r\n                    fragmentShader: ScanSegmentShader,\r\n\r\n                    uniforms: {\r\n\r\n                        u_scanCenterEC: function () {\r\n\r\n                            return Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);\r\n\r\n                        },\r\n\r\n                        u_scanPlaneNormalEC: function () {\r\n\r\n                            var temp = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center, _scratchCartesian4Center);\r\n\r\n                            var temp1 = Cesium.Matrix4.multiplyByVector(viewer.camera._viewMatrix, _Cartesian4Center1, _scratchCartesian4Center1);\r\n\r\n                            _scratchCartesian3Normal.x = temp1.x - temp.x;\r\n\r\n                            _scratchCartesian3Normal.y = temp1.y - temp.y;\r\n\r\n                            _scratchCartesian3Normal.z = temp1.z - temp.z;\r\n\r\n                            Cesium.Cartesian3.normalize(_scratchCartesian3Normal, _scratchCartesian3Normal);\r\n\r\n                            return _scratchCartesian3Normal;\r\n\r\n                        },\r\n\r\n                        u_radius: function () {\r\n\r\n                            return maxRadius * (((new Date()).getTime() - _time) % duration) / duration;\r\n\r\n                        },\r\n\r\n                        u_scanColor: scanColor\r\n\r\n                    }\r\n\r\n                });\r\n\r\n                viewer.scene.postProcessStages.add(ScanPostStage);\r\n\r\n            }\r\n        },\r\n    };\r\n</script>\r\n\r\n<style scoped>\r\n    #cesiumContainer1 {\r\n        width: 100%;\r\n        height: 100vh;\r\n        margin: 0;\r\n        padding: 0;\r\n        overflow: hidden;\r\n    }\r\n</style>","import mod from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.5@vue-loader/lib/index.js??vue-loader-options!./dynamicRadar.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--12-0!../../../node_modules/_thread-loader@2.1.3@thread-loader/dist/cjs.js!../../../node_modules/_babel-loader@8.2.2@babel-loader/lib/index.js!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.5@vue-loader/lib/index.js??vue-loader-options!./dynamicRadar.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./dynamicRadar.vue?vue&type=template&id=c38cad20&scoped=true&\"\nimport script from \"./dynamicRadar.vue?vue&type=script&lang=js&\"\nexport * from \"./dynamicRadar.vue?vue&type=script&lang=js&\"\nimport style0 from \"./dynamicRadar.vue?vue&type=style&index=0&id=c38cad20&scoped=true&lang=css&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../node_modules/_vue-loader@15.9.5@vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  \"c38cad20\",\n  null\n  \n)\n\nexport default component.exports","export * from \"-!../../../node_modules/_mini-css-extract-plugin@0.9.0@mini-css-extract-plugin/dist/loader.js??ref--6-oneOf-1-0!../../../node_modules/_css-loader@3.6.0@css-loader/dist/cjs.js??ref--6-oneOf-1-1!../../../node_modules/_vue-loader@15.9.5@vue-loader/lib/loaders/stylePostLoader.js!../../../node_modules/_postcss-loader@3.0.0@postcss-loader/src/index.js??ref--6-oneOf-1-2!../../../node_modules/_cache-loader@4.1.0@cache-loader/dist/cjs.js??ref--0-0!../../../node_modules/_vue-loader@15.9.5@vue-loader/lib/index.js??vue-loader-options!./dynamicRadar.vue?vue&type=style&index=0&id=c38cad20&scoped=true&lang=css&\""],"sourceRoot":""}