(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-b5bab280"],{"08bc":function(e,n,a){"use strict";a.r(n);var t=function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("div",{attrs:{id:"cesiumContainer1"}})},i=[],r=null,o={name:"goSH",props:{},data:function(){return{tileset:null}},computed:{},watch:{},components:{},created:function(){},mounted:function(){this.init()},methods:{init:function(){var e={infoBox:!1,selectionIndicator:!1,geocoder:!1,homeButton:!1,timeline:!1,navigationHelpButton:!1,fullscreenButton:!1,scene3DOnly:!0,animation:!1,imageryProvider:new Cesium.ArcGisMapServerImageryProvider({url:"http://cache1.arcgisonline.cn/ArcGIS/rest/services/ChinaOnlineStreetPurplishBlue/MapServer"}),baseLayerPicker:!1};Cesium.Ion.defaultAccessToken="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIzZjFjYmZmNS1hYmNjLTRhZWUtYjlkNi02ODVmOGRjNGQ2N2MiLCJpZCI6Mzg4MzUsImlhdCI6MTYwNjg3Mzk0MX0.R0iO5eELEnpRqQCzoa33UZakcsTYUidaTP9nLa342wY",r=new Cesium.Viewer("cesiumContainer1",e),r._cesiumWidget._creditContainer.style.display="none",r.scene.camera.flyTo({destination:Cesium.Cartesian3.fromDegrees(121.41440447172941,31.148724746744023,75e3)}),this.initData();var n=new Cesium.Cartographic(Cesium.Math.toRadians(121.41440447172941),Cesium.Math.toRadians(31.148724746744023),1e3),a=new Cesium.Color(0,0,1,1);this.AddCircleScanPostStage(r,n,1e4,a,4e3)},initData:function(e,n){r.scene.globe.depthTestAgainstTerrain=!0;e="121.41440447172941",n="31.148724746744023";var a=new Cesium.Cartographic(Cesium.Math.toRadians(e),Cesium.Math.toRadians(n),5e3),t=new Cesium.Color(1,0,0,1),i=4e3,o=8e3;this.addRadarScanPostStage(a,o,t,i)},addRadarScanPostStage:function(e,n,a,t){console.log(e);var i="uniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nuniform vec4 u_scanCenterEC;\nuniform vec3 u_scanPlaneNormalEC;\nuniform vec3 u_scanLineNormalEC;\nuniform float u_radius;\nuniform vec4 u_scanColor;\nvec4 toEye(in vec2 uv, in float depth)\n {\n vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n posInCamera =posInCamera / posInCamera.w;\n return posInCamera;\n }\nbool isPointOnLineRight(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n{\nvec3 v01 = testPt - ptOnLine;\nnormalize(v01);\nvec3 temp = cross(v01, lineNormal);\nfloat d = dot(temp, u_scanPlaneNormalEC);\nreturn d > 0.5;\n}\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n{\nvec3 v01 = point -planeOrigin;\nfloat d = dot(planeNormal, v01) ;\nreturn (point - planeNormal * d);\n}\nfloat distancePointToLine(in vec3 ptOnLine, in vec3 lineNormal, in vec3 testPt)\n{\nvec3 tempPt = pointProjectOnPlane(lineNormal, ptOnLine, testPt);\nreturn length(tempPt - ptOnLine);\n}\nfloat getDepth(in vec4 depth)\n{\nfloat z_window = czm_unpackDepth(depth);\nz_window = czm_reverseLogDepth(z_window);\nfloat n_range = czm_depthRange.near;\nfloat f_range = czm_depthRange.far;\nreturn (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nvoid main()\n{\ngl_FragColor = texture2D(colorTexture, v_textureCoordinates);\nfloat depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\nvec4 viewPos = toEye(v_textureCoordinates, depth);\nvec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\nfloat dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\nfloat twou_radius = u_radius * 2.0;\nif(dis < u_radius)\n{\nfloat f0 = 1.0 -abs(u_radius - dis) / u_radius;\nf0 = pow(f0, 64.0);\nvec3 lineEndPt = vec3(u_scanCenterEC.xyz) + u_scanLineNormalEC * u_radius;\nfloat f = 0.0;\nif(isPointOnLineRight(u_scanCenterEC.xyz, u_scanLineNormalEC.xyz, prjOnPlane.xyz))\n{\nfloat dis1= length(prjOnPlane.xyz - lineEndPt);\nf = abs(twou_radius -dis1) / twou_radius;\nf = pow(f, 3.0);\n}\ngl_FragColor = mix(gl_FragColor, u_scanColor, f + f0);\n}\n}\n",o=Cesium.Cartographic.toCartesian(e),s=new Cesium.Cartesian4(o.x,o.y,o.z,1),u=new Cesium.Cartographic(e.longitude,e.latitude,e.height+500),c=Cesium.Cartographic.toCartesian(u),l=new Cesium.Cartesian4(c.x,c.y,c.z,1),m=new Cesium.Cartographic(e.longitude+Cesium.Math.toRadians(.001),e.latitude,e.height),C=Cesium.Cartographic.toCartesian(m),d=new Cesium.Cartesian4(C.x,C.y,C.z,1),p=new Cesium.Quaternion,v=new Cesium.Matrix3,_=(new Date).getTime(),f=new Cesium.Cartesian4,g=new Cesium.Cartesian4,x=new Cesium.Cartesian4,h=new Cesium.Cartesian3,w=new Cesium.Cartesian3,y=new Cesium.PostProcessStage({fragmentShader:i,uniforms:{u_scanCenterEC:function(){return Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,s,f)},u_scanPlaneNormalEC:function(){var e=Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,s,f),n=Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,l,g);return h.x=n.x-e.x,h.y=n.y-e.y,h.z=n.z-e.z,Cesium.Cartesian3.normalize(h,h),h},u_radius:n,u_scanLineNormalEC:function(){var e=Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,s,f),n=Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,l,g),a=Cesium.Matrix4.multiplyByVector(r.camera._viewMatrix,d,x);h.x=n.x-e.x,h.y=n.y-e.y,h.z=n.z-e.z,Cesium.Cartesian3.normalize(h,h),w.x=a.x-e.x,w.y=a.y-e.y,w.z=a.z-e.z;var i=((new Date).getTime()-_)%t/t;return Cesium.Quaternion.fromAxisAngle(h,i*Cesium.Math.PI*2,p),Cesium.Matrix3.fromQuaternion(p,v),Cesium.Matrix3.multiplyByVector(v,w,w),Cesium.Cartesian3.normalize(w,w),w},u_scanColor:a}});r.scene.postProcessStages.add(y)},AddCircleScanPostStage:function(e,n,a,t,i){var r="uniform sampler2D colorTexture;\nuniform sampler2D depthTexture;\nvarying vec2 v_textureCoordinates;\nuniform vec4 u_scanCenterEC;\nuniform vec3 u_scanPlaneNormalEC;\nuniform float u_radius;\nuniform vec4 u_scanColor;\nvec4 toEye(in vec2 uv, in float depth)\n {\n vec2 xy = vec2((uv.x * 2.0 - 1.0),(uv.y * 2.0 - 1.0));\n vec4 posInCamera =czm_inverseProjection * vec4(xy, depth, 1.0);\n posInCamera =posInCamera / posInCamera.w;\n return posInCamera;\n }\nvec3 pointProjectOnPlane(in vec3 planeNormal, in vec3 planeOrigin, in vec3 point)\n{\nvec3 v01 = point -planeOrigin;\nfloat d = dot(planeNormal, v01) ;\nreturn (point - planeNormal * d);\n}\nfloat getDepth(in vec4 depth)\n{\nfloat z_window = czm_unpackDepth(depth);\nz_window = czm_reverseLogDepth(z_window);\nfloat n_range = czm_depthRange.near;\nfloat f_range = czm_depthRange.far;\nreturn (2.0 * z_window - n_range - f_range) / (f_range - n_range);\n}\nvoid main()\n{\ngl_FragColor = texture2D(colorTexture, v_textureCoordinates);\nfloat depth = getDepth( texture2D(depthTexture, v_textureCoordinates));\nvec4 viewPos = toEye(v_textureCoordinates, depth);\nvec3 prjOnPlane = pointProjectOnPlane(u_scanPlaneNormalEC.xyz, u_scanCenterEC.xyz, viewPos.xyz);\nfloat dis = length(prjOnPlane.xyz - u_scanCenterEC.xyz);\nif(dis < u_radius)\n{\nfloat f = 1.0 -abs(u_radius - dis) / u_radius;\nf = pow(f, 4.0);\ngl_FragColor = mix(gl_FragColor, u_scanColor, f);\n}\n}\n",o=Cesium.Cartographic.toCartesian(n),s=new Cesium.Cartesian4(o.x,o.y,o.z,1),u=new Cesium.Cartographic(n.longitude,n.latitude,n.height+500),c=Cesium.Cartographic.toCartesian(u),l=new Cesium.Cartesian4(c.x,c.y,c.z,1),m=(new Date).getTime(),C=new Cesium.Cartesian4,d=new Cesium.Cartesian4,p=new Cesium.Cartesian3,v=new Cesium.PostProcessStage({fragmentShader:r,uniforms:{u_scanCenterEC:function(){return Cesium.Matrix4.multiplyByVector(e.camera._viewMatrix,s,C)},u_scanPlaneNormalEC:function(){var n=Cesium.Matrix4.multiplyByVector(e.camera._viewMatrix,s,C),a=Cesium.Matrix4.multiplyByVector(e.camera._viewMatrix,l,d);return p.x=a.x-n.x,p.y=a.y-n.y,p.z=a.z-n.z,Cesium.Cartesian3.normalize(p,p),p},u_radius:function(){return a*(((new Date).getTime()-m)%i)/i},u_scanColor:t}});e.scene.postProcessStages.add(v)}}},s=o,u=(a("840f"),a("c701")),c=Object(u["a"])(s,t,i,!1,null,"c38cad20",null);n["default"]=c.exports},"1dba":function(e,n,a){},"840f":function(e,n,a){"use strict";a("1dba")}}]);
//# sourceMappingURL=chunk-b5bab280.d1723d87.js.map